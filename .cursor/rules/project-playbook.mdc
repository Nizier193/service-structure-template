---
alwaysApply: true
---

# Playbook: как агент должен создавать проект по ТЗ (понятно, профессионально, без спагетти)

Этот файл дополняет `/.cursor/rules/code-design.mdc`. Если правила конфликтуют — приоритет у `code-design.mdc`.

## Цель

Сделать проект так, чтобы:
- разработчик быстро понял архитектуру и точки входа;
- изменения были маленькими и контролируемыми;
- тесты покрывали ключевую бизнес-логику;
- БД и миграции были воспроизводимыми;
- логи позволяли диагностировать проблемы без “шума”.

## Как агент работает (итерационный процесс)

Обязательно:
- Перед кодом: кратко сформулировать **что делаем**, **где меняем**, **как проверим**.
- Работать маленькими шагами: **не больше 2 файлов за один цикл** (см. `code-design.mdc`).
- Каждая правка должна быть объяснима: “почему” и “как проверить”.
- Любая новая фича = минимум 1 тест (кроме чисто инфраструктурных правок).

Нельзя:
- Делать большой рефакторинг “за раз”.
- Делать импорты внутри функций (кроме крайней необходимости).
- Писать “код ради кода” (сложность только если она реально нужна).

## Структура проекта (ориентир)

Рекомендуемая структура модулей в `backend/app/src/modules/<module_name>/`:
- `router.py`: HTTP слой (FastAPI). Валидация входа, DI, формирование ответа.
- `service.py`: бизнес-логика (use-cases). Тут принимаются решения.
- `repository.py`: доступ к данным (SQLAlchemy/Redis/внешние сервисы).
- `schemas.py`: SQLAlchemy ORM модели (таблицы) и `.to_dict()` если нужно.
- `models.py`: Pydantic модели запросов/ответов.

Рекомендуемая структура инфраструктуры в `backend/app/core/`:
- `config.py`: Pydantic Settings, только настройки.
- `database.py`: engine + session + `get_db`.
- `logger.py`: форматтер/фильтры, request_id (contextvars).
- `middleware/`: кросс-катинг (tracing/auth/etc).

## Разделение ответственности (важно)

Router (HTTP слой):
- принимает запрос, валидирует вход (Pydantic);
- вызывает service/repository;
- возвращает `JSONResponse`/модель;
- логирует только **бизнес-события уровня INFO** (когда это полезно).

Service (бизнес слой):
- содержит основную логику;
- orchestrates репозитории/внешние сервисы;
- логирует **DEBUG** для технических деталей и **INFO** для важных этапов.

Repository (данные):
- делает запросы к БД;
- не решает бизнес-вопросы;
- логирует **DEBUG** только полезные факты (например count/параметры пагинации), без “result объекта”.

## Авторизация (JWT) — как делать правильно

Правильно:
- Пароль проверяется в `POST /auth/login` (router + service), это бизнес-операция.
- Проверка JWT делается через **Dependency Injection** на приватных эндпоинтах:
  - `user_id: str = Depends(get_current_user_id)`
- Логику JWT держать в `core/middleware/auth/`:
  - `jwt_handler.py`: encode/decode
  - `dependencies.py`: DI-функции для роутеров

Нельзя:
- Проверять пароль в middleware “для всех запросов”.
- Логировать пароль, хеш, токены.

## Логирование (простая схема: DEBUG/INFO/ERROR)

Правила:
- DEBUG: технические детали (кэш hit/miss, count, параметры запроса, внутренняя диагностика).
- INFO: бизнес-события (не найдено, вернули список, успешный логин/регистрация).
- ERROR: ошибки с контекстом (использовать `exc_info=True` где это уместно).

Формат:
- Всегда полагаться на `request_id` из `core/logger.py` + tracing middleware.
- Не дублировать “START/END” запроса в роутерах (это задача tracing).

## База данных: миграции и дампы (Alembic + pg_dump)

Правило “как в проде”:
- **Схема БД** управляется Alembic миграциями (в git).
- **Данные** бэкапятся дампами (в файлы/хранилище).

Обязательно:
- Любое изменение ORM модели → миграция Alembic.
- Приложение НЕ делает `create_all` при старте (миграции применяются отдельно).

## Тестирование (минимум)

Обязательно:
- Тестировать “сквозные” сценарии:
  - регистрация → логин → доступ к приватному эндпоинту с JWT
  - публичный эндпоинт доступен без токена
- Разделять тесты:
  - unit (service/repository) — если возможно без реальной БД
  - e2e/integration — через поднятый docker-compose

Правила тестов:
- Тест должен быть читаемым и коротким: arrange → act → assert.
- Тесты не должны зависеть от порядка выполнения.
- Тестовые данные создавать явно (seed/fixtures).

## Документация проекта (минимальный набор)

В проекте должны быть:
- `README.md` (корень): как запустить (docker compose), как прогнать тесты, где конфиги.
- `backend/README.md`: backend specifics (миграции, дампы, переменные).
- `backend/docs/DB.md`: команды migrate/backup/restore, как устроены модели/миграции.
- `backend/docs/LOGGING.md`: уровни и примеры.

## Если потребуется MySQL (позже)

Принцип тот же:
- Alembic остаётся.
- Меняются:
  - `DATABASE_URI`
  - драйверы (например asyncpg → aiomysql/asyncmy)
  - docker-compose сервис БД

